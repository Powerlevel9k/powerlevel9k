# vim:ft=zsh ts=2 sw=2 sts=2 et fenc=utf-8
################################################################
# @title powerlevel9k Segment - Battery
# @source [powerlevel9k](https://github.com/bhilburn/powerlevel9k)
##

################################################################
# Register segment
# Parameters:
#   segment_name  context  background  foreground  Generic  Flat/Awesome-Patched  Awesome-FontConfig  Awesome-Mapped-FontConfig  NerdFont
#                                                                                                ðŸ”‹          î¢”          ðŸ”‹            ï‰€                                        ï‰€
p9k::register_segment "BATTERY" "LOW"           "${DEFAULT_COLOR}" "red"                        $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '
p9k::register_segment "BATTERY" "CHARGING"      "${DEFAULT_COLOR}" "yellow"                     $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '
p9k::register_segment "BATTERY" "CHARGED"       "${DEFAULT_COLOR}" "green"                      $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '
p9k::register_segment "BATTERY" "DISCONNECTED"  "${DEFAULT_COLOR}" "${DEFAULT_COLOR_INVERTED}"  $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '

################################################################
# Register segment default values
p9k::set_default P9K_BATTERY_LOW_THRESHOLD 10
# Default behavior: Be verbose!
p9k::set_default P9K_BATTERY_VERBOSE true

################################################################
# @description
#   Displays the battery statys in levels and colors.
##
# @args
#   $1 string Alignment - left | right
#   $2 integer Segment index
#   $3 boolean Whether the segment should be joined
##
prompt_battery() {
  local ROOT_PREFIX="${4}"
  # The battery can have four different states - default to 'unknown'.
  local current_state='unknown'

  if [[ $__P9K_OS =~ OSX && -f "${ROOT_PREFIX}"/usr/bin/pmset && -x "${ROOT_PREFIX}"/usr/bin/pmset ]]; then
    # obtain battery information from system
    # split lines into an array
    local raw_data=("${(@f)$(${ROOT_PREFIX}/usr/bin/pmset -g batt)}")
    # use only second line
    raw_data=${raw_data[2]}
    # return if there is no battery on system
    [[ ! $raw_data =~ "InternalBattery" ]] && return

    # Time remaining on battery operation (charging/discharging)
    local tstring=${${(s: :)${${(s:; :)raw_data}[3]}}[1]}
    # If time has not been calculated by system yet
    [[ $tstring =~ '(\(no|not)' ]] && tstring="..."

    # percent of battery charged
    typeset -i 10 bat_percent
    [[ "${raw_data}" =~ "([0-9]+)%" ]] && bat_percent="${match[1]}"

    local remain=""
    # Logic for string output
    case "${${(s:; :)raw_data}[2]}" in
      # for a short time after attaching power, status will be 'AC attached;'
      'charging'|'finishing charge'|'AC attached')
        current_state="charging"
        remain=" ($tstring)"
      ;;
      'discharging')
        [[ $bat_percent -lt $P9K_BATTERY_LOW_THRESHOLD ]] && current_state="low" || current_state="disconnected"
        remain=" ($tstring)"
      ;;
      *)
        current_state="charged"
      ;;
    esac
  fi

  if [[ "$__P9K_OS" == 'Linux' ]] || [[ "$__P9K_OS" == 'Android' ]]; then
    local sysp="${ROOT_PREFIX}/sys/class/power_supply"
    local potential_bats=( "$sysp/*" )
    [[ ${#${(M)potential_bats:#*(BAT|battery)*}} ]] \
      && local bats=(${$(ls -d $sysp/(battery|BAT*))}) \
      || return

    local energy_now="0"
    local energy_full="0"
    local power_now="0"
    local battery_status_full=true
    local battery_status_charging=false
    for bat in $bats; do
      energy_now+="+ $(cat $bat/(energy|charge)_now)"
      energy_full+="+ $(cat $bat/(energy|charge)_full)"
      power_now+="+ $(cat $bat/(power|current)_now)"
      [[ $(cat $bat/status) != Full ]] && battery_status_full=false
      [[ $(cat $bat/status) == Charging ]] && battery_status_charging=true
    done
    energy_now=$(($energy_now))
    energy_full=$(($energy_full))
    power_now=$(($power_now))

    local capacity=$(( 100 * $energy_now / $energy_full ))
    [[ $capacity -gt 100 ]] \
      && local bat_percent=100 \
      || local bat_percent=$capacity
    [[ $battery_status_full == true || $battery_status_charging == true ]] \
      && local connected=true

    if [[ -z $connected ]]; then
      [[ $bat_percent -lt $P9K_BATTERY_LOW_THRESHOLD ]] \
        && current_state="low" \
        || current_state="disconnected"
    else
      [[ $bat_percent =~ 100 ]] && current_state="charged"
      [[ $bat_percent -lt 100 ]] && current_state="charging"
    fi

    # calculate (dis)charging time
    if [[ $battery_status_full == true ]]; then
      # ignore full case (this just keeps a flat if structure)
    elif [[ $power_now -gt 0 ]]; then
      local tstring
      if [[ $battery_status_charging == true ]]; then
        tstring=$(( 60 * ($energy_full - $energy_now) / $power_now ))
      else
        tstring=$(( 60 * $energy_now / $power_now ))
      fi
      # format to h:mm
      tstring="$(($tstring/60)):${(l#2##0#)$(($tstring%60))}"
    else
      tstring="..."
    fi
    [[ -n $tstring ]] && local remain=" ($tstring)"
  fi

  # return if P9K_BATTERY_HIDE_ABOVE_THRESHOLD is set and the battery percentage is greater or equal
  if p9k::defined P9K_BATTERY_HIDE_ABOVE_THRESHOLD && [[ "${bat_percent}" -ge $P9K_BATTERY_HIDE_ABOVE_THRESHOLD ]]; then
    return
  fi

  local message
  if [[ "$P9K_BATTERY_VERBOSE" == true ]]; then
    message="$bat_percent%%$remain"
  else
    message="$bat_percent%%"
  fi

  # override default icon if we are using battery stages
  local overideIcon="" overideBg="" segment
  declare -i offset
  if [[ -n "$P9K_BATTERY_STAGES" ]] && [[ -n "$P9K_BATTERY_LEVEL_BACKGROUND" ]]; then
    # override default icon if we are using battery stages
    if [[ -n "$P9K_BATTERY_STAGES" ]]; then
      segment=$(( 100.0 / (${#P9K_BATTERY_STAGES} - 1 ) ))
      if [[ ${segment} > 1 ]]; then
        offset=$(( (${bat_percent} / $segment) ))
        # check if the stages are in an array or a string
        [[ "${(t)P9K_BATTERY_STAGES}" =~ "array" ]] && overideIcon="$P9K_BATTERY_STAGES[$offset]" || overideIcon="${P9K_BATTERY_STAGES:$offset:1}"
      fi
    fi

    # override the default color if we are using a color level array
    if [[ -n "$P9K_BATTERY_LEVEL_BACKGROUND" ]] && [[ "${(t)P9K_BATTERY_LEVEL_BACKGROUND}" =~ "array" ]]; then
      segment=$(( 100.0 / (${#P9K_BATTERY_LEVEL_BACKGROUND} - 1 ) ))
      offset=$(( (${bat_percent} / $segment) + 1 ))
      overideBg="$(p9k::background_color ${P9K_BATTERY_LEVEL_BACKGROUND[$offset]})"
    fi
  fi
  unset offset
  # Draw the prompt_segment
  p9k::prepare_segment "$0" "${(U)current_state}" $1 "$2" $3 "${message}" "" "${overideIcon}" "${overideBg}"
}
