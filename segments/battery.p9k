# vim:ft=zsh ts=2 sw=2 sts=2 et fenc=utf-8
################################################################
# @title powerlevel9k Segment - Battery
# @source [powerlevel9k](https://github.com/bhilburn/powerlevel9k)
##

################################################################
# Register segment
# Parameters:
#   segment_name  context  background  foreground  Generic  Flat/Awesome-Patched  Awesome-FontConfig  Awesome-Mapped-FontConfig  NerdFont
#                                                                                                ðŸ”‹          î¢”          ðŸ”‹            ï‰€                                        ï‰€
p9k::register_segment "BATTERY" "LOW"           "${DEFAULT_COLOR}" "red"                        $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '
p9k::register_segment "BATTERY" "CHARGING"      "${DEFAULT_COLOR}" "yellow"                     $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '
p9k::register_segment "BATTERY" "CHARGED"       "${DEFAULT_COLOR}" "green"                      $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '
p9k::register_segment "BATTERY" "DISCONNECTED"  "${DEFAULT_COLOR}" "${DEFAULT_COLOR_INVERTED}"  $'\U1F50B'  $'\uE894'  $'\U1F50B'  '\u'${CODEPOINT_OF_AWESOME_BATTERY_FULL}  $'\uF240 '

################################################################
# Register segment default values
p9k::set_default P9K_BATTERY_LOW_THRESHOLD 10
# Default behavior: Be verbose!
p9k::set_default P9K_BATTERY_VERBOSE true

################################################################
# @description
#   Displays the battery statys in levels and colors.
##
# @args
#   $1 string Alignment - left | right
#   $2 integer Segment index
#   $3 boolean Whether the segment should be joined
##
prompt_battery() {
  local ROOT_PREFIX="${4}"
  # The battery can have four different states - default to 'unknown'.
  local current_state='unknown'

  if [[ $__P9K_OS =~ OSX && -f "${ROOT_PREFIX}"/usr/bin/pmset && -x "${ROOT_PREFIX}"/usr/bin/pmset ]]; then
    # obtain battery information from system
    # split lines into an array
    local raw_data=("${(@f)$(${ROOT_PREFIX}/usr/bin/pmset -g batt)}")
    # use only second line
    raw_data=${raw_data[2]}
    # return if there is no battery on system
    [[ ! $raw_data =~ "InternalBattery" ]] && return

    # Time remaining on battery operation (charging/discharging)
    local tstring=${${(s: :)${${(s:; :)raw_data}[3]}}[1]}
    # If time has not been calculated by system yet
    [[ $tstring =~ '(\(no|not)' ]] && tstring="..."

    # percent of battery charged
    typeset -i 10 bat_percent
    [[ "${raw_data}" =~ "([0-9]+)%" ]] && bat_percent="${match[1]}"

    local remain=""
    # Logic for string output
    case "${${(s:; :)raw_data}[2]}" in
      # for a short time after attaching power, status will be 'AC attached;'
      'charging'|'finishing charge'|'AC attached')
        current_state="charging"
        remain=" ($tstring)"
      ;;
      'discharging')
        [[ $bat_percent -lt $P9K_BATTERY_LOW_THRESHOLD ]] && current_state="low" || current_state="disconnected"
        remain=" ($tstring)"
      ;;
      *)
        current_state="charged"
      ;;
    esac
  fi

  if [[ "$__P9K_OS" == 'Linux' ]] || [[ "$__P9K_OS" == 'Android' ]]; then
    local sysp="${ROOT_PREFIX}/sys/class/power_supply"

    # Reported BAT0 or BAT1 depending on kernel version
    [[ -a $sysp/BAT0 ]] && local bat0=$sysp/BAT0
    [[ -a $sysp/BAT1 ]] && local bat1=$sysp/BAT1

    # Android-related
    # Tested on: Moto G falcon (CM 13.0)
    [[ -a $sysp/battery ]] && local bat0=$sysp/battery

    local capacity battery_status
    if (( ${+bat0} && ${+bat1} )); then
      # two batteries
      capacity=$(( ( $(cat $bat0/capacity) * $(cat $bat0/(energy|charge)_full) \
        + $(cat $bat1/capacity) * $(cat $bat1/(energy|charge)_full) )          \
        / ( $(cat $bat0/(energy|charge)_full) + $(cat $bat1/(energy|charge)_full) ) ))
      [[ $(<${bat0}/status) =~ Charging || $(<${bat1}/status) =~ Charging ]] \
        && battery_status=Charging
      [[ $(<${bat0}/status) =~ Full && $(<${bat1}/status) =~ Full ]] \
        && battery_status=Full
    elif (( ${+bat0} ^^ ${+bat1} )); then
      # only bat0 OR bat1 isset
      capacity=$(<${bat0}${bat1}/capacity)
      battery_status=$(<${bat0}${bat1}/status)
    else
      # Return if no battery found
      return
    fi

    [[ $capacity -gt 100 ]] \
      && local bat_percent=100 \
      || local bat_percent=$capacity
    [[ $battery_status =~ Charging || $battery_status =~ Full ]] \
      && local connected=true

    if [[ -z $connected ]]; then
      [[ $bat_percent -lt $P9K_BATTERY_LOW_THRESHOLD ]] \
        && current_state="low" \
        || current_state="disconnected"
    else
      [[ $bat_percent =~ 100 ]] && current_state="charged"
      [[ $bat_percent -lt 100 ]] && current_state="charging"
    fi
    if [[ -f ${ROOT_PREFIX}/usr/bin/acpi ]]; then
      local time_remaining1=${${(s: :)${(s:Battery:)$(${ROOT_PREFIX}/usr/bin/acpi)}[1]}[4]}
      local time_remaining2=${${(s: :)${(s:Battery:)$(${ROOT_PREFIX}/usr/bin/acpi)}[2]}[4]}
      [[ -z $time_remaining2 ]] \
        && local time_remaining=$time_remaining1 \
        || local time_remaining=$time_remaining2
      if [[ $time_remaining =~ "rate" ]]; then
        local tstring="..."
      elif [[ $time_remaining =~ "[[:digit:]]+" ]]; then
        local tstring=${(f)$(date -u -d "$(echo $time_remaining)" +%k:%M 2> /dev/null)}
      fi
    fi
    [[ -n $tstring ]] && local remain=" ($tstring)"
  fi

  # return if P9K_BATTERY_HIDE_ABOVE_THRESHOLD is set and the battery percentage is greater or equal
  if p9k::defined P9K_BATTERY_HIDE_ABOVE_THRESHOLD && [[ "${bat_percent}" -ge $P9K_BATTERY_HIDE_ABOVE_THRESHOLD ]]; then
    return
  fi

  local message
  if [[ "$P9K_BATTERY_VERBOSE" == true ]]; then
    message="$bat_percent%%$remain"
  else
    message="$bat_percent%%"
  fi

  # override default icon if we are using battery stages
  local overideIcon="" overideBg="" segment
  declare -i offset
  if [[ -n "$P9K_BATTERY_STAGES" ]] && [[ -n "$P9K_BATTERY_LEVEL_BACKGROUND" ]]; then
    # override default icon if we are using battery stages
    if [[ -n "$P9K_BATTERY_STAGES" ]]; then
      segment=$(( 100.0 / (${#P9K_BATTERY_STAGES} - 1 ) ))
      if [[ ${segment} > 1 ]]; then
        offset=$(( (${bat_percent} / $segment) ))
        # check if the stages are in an array or a string
        [[ "${(t)P9K_BATTERY_STAGES}" =~ "array" ]] && overideIcon="$P9K_BATTERY_STAGES[$offset]" || overideIcon="${P9K_BATTERY_STAGES:$offset:1}"
      fi
    fi

    # override the default color if we are using a color level array
    if [[ -n "$P9K_BATTERY_LEVEL_BACKGROUND" ]] && [[ "${(t)P9K_BATTERY_LEVEL_BACKGROUND}" =~ "array" ]]; then
      segment=$(( 100.0 / (${#P9K_BATTERY_LEVEL_BACKGROUND} - 1 ) ))
      offset=$(( (${bat_percent} / $segment) + 1 ))
      overideBg="$(p9k::background_color ${P9K_BATTERY_LEVEL_BACKGROUND[$offset]})"
    fi
  fi
  unset offset
  # Draw the prompt_segment
  p9k::prepare_segment "$0" "${(U)current_state}" $1 "$2" $3 "${message}" "" "${overideIcon}" "${overideBg}"
}
