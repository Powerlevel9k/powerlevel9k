#!/usr/bin/env zsh
# vim:ft=zsh ts=2 sw=2 sts=2 et fenc=utf-8
################################################################
# @title powerlevel9k Segment - Dir Writable
# @source https://github.com/bhilburn/powerlevel9k
##
# @authors
#   Ben Hilburn (bhilburn)
#   Dominik Ritter (dritter)
##

################################################################
# Register segment icon
# Parameters:
#   name_of_icon  Generic  Flat/Awesome-Patched  Awesome-FontConfig  Awesome-Mapped-FontConfig  NerdFont
#                                                                                
registerIcon "HOME_ICON"  ''  $'\uE12C'  $'\uF015'  '\u'$CODEPOINT_OF_AWESOME_HOME  $'\uF015'
#                                                                                           
registerIcon "HOME_SUB_ICON"  ''  $'\uE18D'  $'\uF07C'  '\u'$CODEPOINT_OF_AWESOME_FOLDER_OPEN  $'\uF07C'
#                                                                                      
registerIcon "FOLDER_ICON"  ''  $'\uE818'  $'\uF115'  '\u'$CODEPOINT_OF_AWESOME_FOLDER_O  $'\uF115'
#                                                                                        
registerIcon "LOCK_ICON"  $'\UE0A2'  $'\UE138'  $'\UF023'  '\u'$CODEPOINT_OF_AWESOME_LOCK  $'\UF023'

setDefault P9K_DIR_PATH_SEPARATOR "/"
setDefault P9K_HOME_FOLDER_ABBREVIATION "~"
setDefault P9K_DIR_PATH_HIGHLIGHT_BOLD false
################################################################
# @description
#   Display information about the current working directory.
##
# @args
#   $1 string Alignment - left | right
#   $2 integer Segment index
#   $3 boolean Whether the segment should be joined
##
prompt_dir() {
  # using $PWD instead of "$(print -P '%~')" to allow use of P9K_DIR_PATH_ABSOLUTE
  local current_path=$PWD # WAS: local current_path="$(print -P '%~')"
  # check if the user wants to use absolute paths or "~" paths
  [[ ${(L)P9K_DIR_PATH_ABSOLUTE} != "true" ]] && current_path=${current_path//$HOME/"~"}
  # declare all local variables
  local paths directory test_dir test_dir_length trunc_path threshhold
  # if we are not in "~" or "/", split the paths into an array and exclude "~"
  (( ${#current_path} > 1 )) && paths=(${(s:/:)${current_path//"~\/"/}}) || paths=()
  # only run the code if SHORTEN_DIR_LENGTH is set, or we are using the two strategies that don't rely on it.
  if [[ -n "$P9K_SHORTEN_DIR_LENGTH" || "$P9K_SHORTEN_STRATEGY" == "truncate_with_folder_marker" || "$P9K_SHORTEN_STRATEGY" == "truncate_to_last" ]]; then
    setDefault P9K_SHORTEN_DELIMITER "\u2026"
    # convert delimiter from unicode to literal character, so that we can get the correct length later
    local delim=$(echo -n $P9K_SHORTEN_DELIMITER)

    case "$P9K_SHORTEN_STRATEGY" in
      truncate_middle)
        # truncate characters from the middle of the path
        current_path=$(truncatePath $current_path $P9K_SHORTEN_DIR_LENGTH $P9K_SHORTEN_DELIMITER "middle")
      ;;
      truncate_from_right)
        # truncate characters from the right of the path
        current_path=$(truncatePath "$current_path" $P9K_SHORTEN_DIR_LENGTH $P9K_SHORTEN_DELIMITER)
      ;;
      truncate_absolute|truncate_absolute_chars)
        # truncate all characters except the last P9K_SHORTEN_DIR_LENGTH characters
        if [ ${#current_path} -gt $(( $P9K_SHORTEN_DIR_LENGTH + ${#P9K_SHORTEN_DELIMITER} )) ]; then
          current_path=$P9K_SHORTEN_DELIMITER${current_path:(-P9K_SHORTEN_DIR_LENGTH)}
        fi
      ;;
      truncate_to_last)
        # truncate all characters before the current directory
        current_path=${current_path##*/}
      ;;
      truncate_to_first_and_last)
        if (( ${#current_path} > 1 )) && (( ${P9K_SHORTEN_DIR_LENGTH} > 0 )); then
          threshhold=$(( ${P9K_SHORTEN_DIR_LENGTH} * 2))
          # if we are in "~", add it back into the paths array
          [[ $current_path == '~'* ]] && paths=("~" "${paths[@]}")
          if (( ${#paths} > $threshhold )); then
            local num=$(( ${#paths} - ${P9K_SHORTEN_DIR_LENGTH} ))
            # repace the middle elements
            for (( i=$P9K_SHORTEN_DIR_LENGTH; i<$num; i++ )); do
              paths[$i+1]=$P9K_SHORTEN_DELIMITER
            done
            [[ $current_path != '~'* ]] && current_path="/" || current_path=""
            current_path+="${(j:/:)paths}"
          fi
        fi
      ;;
      truncate_to_unique)
        # for each parent path component find the shortest unique beginning
        # characters sequence. Source: https://stackoverflow.com/a/45336078
        if (( ${#current_path} > 1 )); then # root and home are exceptions and won't have paths
          local matching
          local cur_path='/'
          [[ $current_path != "~"* ]] && trunc_path='/' || trunc_path=''
          for directory in ${paths[@]}; do
            test_dir=''
            for (( i=0; i<${#directory}; i++ )); do
              test_dir+="${directory:$i:1}"
              matching=("$cur_path"/"$test_dir"*/)
              if [[ ${#matching[@]} -eq 1 ]]; then
                break
              fi
            done
            trunc_path+="$test_dir/"
            cur_path+="$directory/"
          done
          [[ $current_path == "~"* ]] && trunc_path="~/$trunc_path"
          current_path="${trunc_path: : -1}"
        fi
      ;;
      truncate_with_folder_marker)
        if (( ${#paths} > 0 )); then # root and home are exceptions and won't have paths, so skip this
          local last_marked_folder marked_folder
          setDefault P9K_SHORTEN_FOLDER_MARKER ".shorten_folder_marker"

          # Search for the folder marker in the parent directories and
          # buildup a pattern that is removed from the current path
          # later on.
          for marked_folder in $(upsearch $P9K_SHORTEN_FOLDER_MARKER); do
            if [[ "$marked_folder" == "/" ]]; then
              # If we reached root folder, stop upsearch.
              trunc_path="/"
            elif [[ "$marked_folder" == "$HOME" ]]; then
              # If we reached home folder, stop upsearch.
              trunc_path="~"
            elif [[ "${marked_folder%/*}" == $last_marked_folder ]]; then
              trunc_path="${trunc_path%/}/${marked_folder##*/}"
            else
              trunc_path="${trunc_path%/}/$P9K_SHORTEN_DELIMITER/${marked_folder##*/}"
            fi
            last_marked_folder=$marked_folder
          done

          # Replace the shortest possible match of the marked folder from
          # the current path.
          current_path=$trunc_path${current_path#${last_marked_folder}*}
        fi
      ;;
      truncate_with_package_name)
        local name repo_path package_path current_dir zero

        # Get the path of the Git repo, which should have the package.json file
        if [[ $(git rev-parse --is-inside-work-tree 2> /dev/null) == "true" ]]; then
          # Get path from the root of the git repository to the current dir
          local gitPath=$(git rev-parse --show-prefix)
          # Remove trailing slash from git path, so that we can
          # remove that git path from the pwd.
          gitPath=${gitPath%/}
          package_path=${$(pwd)%%$gitPath}
          # Remove trailing slash
          package_path=${package_path%/}
        elif [[ $(git rev-parse --is-inside-git-dir 2> /dev/null) == "true" ]]; then
          package_path=${$(pwd)%%/.git*}
        fi

        # Replace the shortest possible match of the marked folder from
        # the current path. Remove the amount of characters up to the
        # folder marker from the left. Count only the visible characters
        # in the path (this is done by the "zero" pattern; see
        # http://stackoverflow.com/a/40855342/5586433).
        local zero='%([BSUbfksu]|([FB]|){*})'
        trunc_path=$(pwd)
        # Then, find the length of the package_path string, and save the
        # subdirectory path as a substring of the current directory's path from 0
        # to the length of the package path's string
        subdirectory_path=$(truncatePath "${trunc_path:${#${(S%%)package_path//$~zero/}}}" $P9K_SHORTEN_DIR_LENGTH $P9K_SHORTEN_DELIMITER)
        # Parse the 'name' from the package.json; if there are any problems, just
        # print the file path
        defined P9K_DIR_PACKAGE_FILES || P9K_DIR_PACKAGE_FILES=(package.json composer.json)

        local pkgFile="unknown"
        for file in "${P9K_DIR_PACKAGE_FILES[@]}"; do
          if [[ -f "${package_path}/${file}" ]]; then
            pkgFile="${package_path}/${file}"
            break;
          fi
        done

        local packageName=$(jq '.name' ${pkgFile} 2> /dev/null \
          || node -e 'console.log(require(process.argv[1]).name);' ${pkgFile} 2>/dev/null \
          || cat "${pkgFile}" 2> /dev/null | grep -m 1 "\"name\"" | awk -F ':' '{print $2}' | awk -F '"' '{print $2}' 2>/dev/null \
          )
        if [[ -n "${packageName}" ]]; then
          # Instead of printing out the full path, print out the name of the package
          # from the package.json and append the current subdirectory
          current_path="`echo $packageName | tr -d '"'`$subdirectory_path"
        fi
      ;;
      *)
        current_path="$(print -P "%$((P9K_SHORTEN_DIR_LENGTH+1))(c:$P9K_SHORTEN_DELIMITER/:)%${P9K_SHORTEN_DIR_LENGTH}c")"
      ;;
    esac
  fi

  # save state of path for highlighting and bold options
  local path_opt=$current_path

  typeset -AH dir_states
  dir_states=(
    "DEFAULT"         "FOLDER_ICON"
    "HOME"            "HOME_ICON"
    "HOME_SUBFOLDER"  "HOME_SUB_ICON"
    "NOT_WRITABLE"    "LOCK_ICON"
  )
  local state_path="$(print -P '%~')"
  local current_state="DEFAULT"
  if [[ "${P9K_DIR_SHOW_WRITABLE}" == true && ! -w "$PWD" ]]; then
    current_state="NOT_WRITABLE"
  elif [[ $state_path == '~' ]]; then
    current_state="HOME"
  elif [[ $state_path == '~'* ]]; then
    current_state="HOME_SUBFOLDER"
  fi

  # declare variables used for bold and state colors
  local bld_on bld_off dir_state_foreground dir_state_user_foreground
  # test if user wants the last directory printed in bold
  if [[ "${(L)P9K_DIR_PATH_HIGHLIGHT_BOLD}" == "true" ]]; then
    bld_on="%B"
    bld_off="%b"
  else
    bld_on=""
    bld_off=""
  fi
  # determine is the user has set a last directory color
  local dir_state_user_foreground=P9K_DIR_${current_state}_FOREGROUND
  local dir_state_foreground=${(P)dir_state_user_foreground}
  [[ -z ${dir_state_foreground} ]] && dir_state_foreground="${DEFAULT_COLOR}"

  local dir_name base_name
  # use ZSH substitution to get the dirname and basename instead of calling external functions
  dir_name=${path_opt%/*}
  base_name=${path_opt##*/}

  # if the user wants the last directory colored...
  if [[ -n ${P9K_DIR_PATH_HIGHLIGHT_FOREGROUND} ]]; then
    # it the path is "/" or "~"
    if [[ $path_opt == "/" || $path_opt == "~" ]]; then
      current_path="${bld_on}%F{$P9K_DIR_PATH_HIGHLIGHT_FOREGROUND}${current_path}${bld_off}"
    else # has a subfolder
      # test if dirname != basename - they are equal if we use truncate_to_last or truncate_absolute
      if [[ $dir_name != $base_name ]]; then
        current_path="${dir_name}/${bld_on}%F{$P9K_DIR_PATH_HIGHLIGHT_FOREGROUND}${base_name}${bld_off}"
      else
        current_path="${bld_on}%F{$P9K_DIR_PATH_HIGHLIGHT_FOREGROUND}${base_name}${bld_off}"
      fi
    fi
  else # no coloring
    # it the path is "/" or "~"
    if [[ $path_opt == "/" || $path_opt == "~" ]]; then
      current_path="${bld_on}${current_path}${bld_off}"
    else # has a subfolder
      # test if dirname != basename - they are equal if we use truncate_to_last or truncate_absolute
      if [[ $dir_name != $base_name ]]; then
        current_path="${dir_name}/${bld_on}${base_name}${bld_off}"
      else
        current_path="${bld_on}${base_name}${bld_off}"
      fi
    fi
  fi

  # check if we need to omit the first character and only do it if we are not in "~" or "/"
  if [[ "${P9K_DIR_OMIT_FIRST_CHARACTER}" == "true" && $path_opt != "/" && $path_opt != "~" ]]; then
    current_path="${current_path[2,-1]}"
  fi

  # check if the user wants the separator colored.
  if [[ -n ${P9K_DIR_PATH_SEPARATOR_FOREGROUND} && $path_opt != "/" ]]; then
    # because this contains color changing codes, it is easier to set a variable for what should be replaced
    local repl="%F{$P9K_DIR_PATH_SEPARATOR_FOREGROUND}/%F{$dir_state_foreground}"
    # escape the / with a \
    current_path=${current_path//\//$repl}
  fi

  if [[ "${P9K_DIR_PATH_SEPARATOR}" != "/" && $path_opt != "/" ]]; then
    current_path=${current_path//\//$P9K_DIR_PATH_SEPARATOR}
  fi

  if [[ "${P9K_HOME_FOLDER_ABBREVIATION}" != "~" && ! "${(L)P9K_DIR_OMIT_FIRST_CHARACTER}" == "true" ]]; then
    # use :s to only replace the first occurance
    current_path=${current_path:s/~/$P9K_HOME_FOLDER_ABBREVIATION}
  fi

  serializeSegment "$0" "${(U)current_state}" $1 "$2" $3 "blue" "$DEFAULT_COLOR" "${current_path}" "${dir_states[$current_state]}"
}
