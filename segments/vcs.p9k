# vim:ft=zsh ts=2 sw=2 sts=2 et fenc=utf-8
################################################################
# @title powerlevel9k Segment - VCS
# @source [powerlevel9k](https://github.com/bhilburn/powerlevel9k)
##

p9k::set_default P9K_VCS_ACTIONFORMAT_FOREGROUND "red"
p9k::set_default P9K_VCS_HIDE_TAGS false
p9k::set_default P9K_VCS_INTERNAL_HASH_LENGTH "8" # Default: Just display the first 8 characters of our changeset-ID.
p9k::set_default P9K_VCS_SHORTEN_DELIMITER $'\U2026'
p9k::set_default P9K_VCS_SHOW_SUBMODULE_DIRTY true

function +vi-git-untracked() {
  # TODO: check git >= 1.7.2 - see function git_compare_version()
  local FLAGS
  FLAGS=('--porcelain')

  if [[ "$P9K_VCS_SHOW_SUBMODULE_DIRTY" == "false" ]]; then
    FLAGS+='--ignore-submodules=dirty'
  fi

  if [[ $(command git rev-parse --is-inside-work-tree 2> /dev/null) == 'true' && \
      -n $(command git status ${FLAGS} | \grep -E '^\?\?' 2> /dev/null | tail -n1) ]]; then
    hook_com[unstaged]+=" $(p9k::print_icon 'VCS_UNTRACKED_ICON')"
    VCS_WORKDIR_HALF_DIRTY=true
  else
    VCS_WORKDIR_HALF_DIRTY=false
  fi
}

function +vi-git-aheadbehind() {
  local ahead behind branch_name
  local -a gitstatus

  branch_name=$(command git symbolic-ref --short HEAD 2>/dev/null)

  # for git prior to 1.7
  # ahead=$(command git rev-list origin/${branch_name}..HEAD | wc -l)
  ahead=$(command git rev-list "${branch_name}"@{upstream}..HEAD 2>/dev/null | wc -l)
  (( ahead )) && gitstatus+=( " $(p9k::print_icon 'VCS_OUTGOING_CHANGES_ICON')${ahead// /}" )

  # for git prior to 1.7
  # behind=$(command git rev-list HEAD..origin/${branch_name} | wc -l)
  behind=$(command git rev-list HEAD.."${branch_name}"@{upstream} 2>/dev/null | wc -l)
  (( behind )) && gitstatus+=( " $(p9k::print_icon 'VCS_INCOMING_CHANGES_ICON')${behind// /}" )

  hook_com[misc]+=${(j::)gitstatus}
}

function +vi-git-remotebranch() {
  local remote branch_name

  # Are we on a remote-tracking branch?
  remote=${$(command git rev-parse --verify HEAD@{upstream} --symbolic-full-name 2>/dev/null)/refs\/(remotes|heads)\/}
  branch_name=$(command git symbolic-ref --short HEAD 2>/dev/null)

  if [[ -n "$P9K_VCS_SHORTEN_LENGTH" ]] && [[ -n "$P9K_VCS_SHORTEN_MIN_LENGTH" ]]; then
    if [ ${#hook_com[branch]} -gt $P9K_VCS_SHORTEN_MIN_LENGTH ] && [ ${#hook_com[branch]} -gt $P9K_VCS_SHORTEN_LENGTH ]; then
      case "$P9K_VCS_SHORTEN_STRATEGY" in
        truncate_middle)
          hook_com[branch]="$(echo "${branch_name:0:$P9K_VCS_SHORTEN_LENGTH}")$P9K_VCS_SHORTEN_DELIMITER$(echo "${branch_name: -$P9K_VCS_SHORTEN_LENGTH}")"
        ;;
        truncate_from_right)
          hook_com[branch]="$(echo "${branch_name:0:$P9K_VCS_SHORTEN_LENGTH}")$P9K_VCS_SHORTEN_DELIMITER"
        ;;
      esac
    fi
  fi

  hook_com[branch]="$(p9k::print_icon 'VCS_BRANCH_ICON')${hook_com[branch]}"
  # Always show the remote
  #if [[ -n ${remote} ]] ; then
  # Only show the remote if it differs from the local
  if [[ -n ${remote} ]] && [[ "${remote#*/}" != "${branch_name}" ]] ; then
    hook_com[branch]+="$(p9k::print_icon 'VCS_REMOTE_BRANCH_ICON')${remote// /}"
  fi
}

function +vi-git-tagname() {
  if [[ "$P9K_VCS_HIDE_TAGS" == "false" ]]; then
    # If we are on a tag, append the tagname to the current branch string.
    local tag
    tag=$(command git describe --tags --exact-match HEAD 2>/dev/null)

    if [[ -n "${tag}" ]] ; then
      # There is a tag that points to our current commit. Need to determine if we
      # are also on a branch, or are in a DETACHED_HEAD state.
      if [[ -z $(command git symbolic-ref HEAD 2>/dev/null) ]]; then
        # DETACHED_HEAD state. We want to append the tag name to the commit hash
        # and print it. Unfortunately, `vcs_info` blows away the hash when a tag
        # exists, so we have to manually retrieve it and clobber the branch
        # string.
        local revision
        revision=$(command git rev-list -n 1 --abbrev-commit --abbrev=${P9K_VCS_INTERNAL_HASH_LENGTH} HEAD)
        hook_com[branch]="$(p9k::print_icon 'VCS_BRANCH_ICON')${revision} $(p9k::print_icon 'VCS_TAG_ICON')${tag}"
      else
        # We are on both a tag and a branch; print both by appending the tag name.
        hook_com[branch]+=" $(p9k::print_icon 'VCS_TAG_ICON')${tag}"
      fi
    fi
  fi
}

# Show count of stashed changes
# Port from https://github.com/whiteinge/dotfiles/blob/5dfd08d30f7f2749cfc60bc55564c6ea239624d9/.zsh_shouse_prompt#L268
function +vi-git-stash() {
  local -a stashes

  if [[ -s $(command git rev-parse --git-dir)/refs/stash ]] ; then
    stashes=$(command git stash list 2>/dev/null | wc -l)
    hook_com[misc]+=" $(p9k::print_icon 'VCS_STASH_ICON')${stashes// /}"
  fi
}

function +vi-hg-bookmarks() {
  if [[ -n "${hgbmarks[@]}" ]]; then
    hook_com[hg-bookmark-string]=" $(p9k::print_icon 'VCS_BOOKMARK_ICON')${hgbmarks[@]}"

    # To signal that we want to use the sting we just generated, set the special
    # variable `ret' to something other than the default zero:
    ret=1
    return 0
  fi
}

function +vi-vcs-detect-changes() {
  if [[ "${hook_com[vcs]}" == "git" ]]; then

    local remote=$(command git ls-remote --get-url 2> /dev/null)
    if [[ "$remote" =~ "github" ]] then
      vcs_visual_identifier='VCS_GIT_GITHUB_ICON'
    elif [[ "$remote" =~ "bitbucket" ]] then
      vcs_visual_identifier='VCS_GIT_BITBUCKET_ICON'
    elif [[ "$remote" =~ "stash" ]] then
      vcs_visual_identifier='VCS_GIT_BITBUCKET_ICON'
    elif [[ "$remote" =~ "gitlab" ]] then
      vcs_visual_identifier='VCS_GIT_GITLAB_ICON'
    else
      vcs_visual_identifier='VCS_GIT_ICON'
    fi

  elif [[ "${hook_com[vcs]}" == "hg" ]]; then
    vcs_visual_identifier='VCS_HG_ICON'
  elif [[ "${hook_com[vcs]}" == "svn" ]]; then
    vcs_visual_identifier='VCS_SVN_ICON'
  fi

  if [[ -n "${hook_com[staged]}" ]] || [[ -n "${hook_com[unstaged]}" ]]; then
    VCS_WORKDIR_DIRTY=true
  else
    VCS_WORKDIR_DIRTY=false
  fi
}

function +vi-svn-detect-changes() {
  local svn_status="$(svn status)"
  if [[ -n "$(echo "$svn_status" | \grep \^\?)" ]]; then
    hook_com[unstaged]+=" $(p9k::print_icon 'VCS_UNTRACKED_ICON')"
    VCS_WORKDIR_HALF_DIRTY=true
  fi
  if [[ -n "$(echo "$svn_status" | \grep \^\M)" ]]; then
    hook_com[unstaged]+=" $(p9k::print_icon 'VCS_UNSTAGED_ICON')"
    VCS_WORKDIR_DIRTY=true
  fi
  if [[ -n "$(echo "$svn_status" | \grep \^\A)" ]]; then
    hook_com[staged]+=" $(p9k::print_icon 'VCS_STAGED_ICON')"
    VCS_WORKDIR_DIRTY=true
  fi
}

################################################################
# VCS segment: shows the state of your repository, if you are in a folder under
# version control
powerlevel9k_vcs_init() {
  if [[ -n "$P9K_CHANGESET_HASH_LENGTH" ]]; then
    P9K_VCS_INTERNAL_HASH_LENGTH="$P9K_CHANGESET_HASH_LENGTH"
  fi

  # Load VCS_INFO
  autoload -Uz vcs_info

  VCS_WORKDIR_DIRTY=false
  VCS_WORKDIR_HALF_DIRTY=false

  # The vcs segment can have three different states - defaults to 'clean'.
  typeset -gAH vcs_states
  vcs_states=(
    'clean'         'green'
    'modified'      'yellow'
    'untracked'     'green'
  )

  VCS_CHANGESET_PREFIX=''
  if [[ "$P9K_SHOW_CHANGESET" == true ]]; then
    VCS_CHANGESET_PREFIX="$(p9k::print_icon 'VCS_COMMIT_ICON')%0.$P9K_VCS_INTERNAL_HASH_LENGTH""i "
  fi

  zstyle ':vcs_info:*' enable git hg svn
  zstyle ':vcs_info:*' check-for-changes true

  VCS_DEFAULT_FORMAT="$VCS_CHANGESET_PREFIX%b%c%u%m"
  zstyle ':vcs_info:*' formats "$VCS_DEFAULT_FORMAT"

  zstyle ':vcs_info:*' actionformats "%b %F{${P9K_VCS_ACTIONFORMAT_FOREGROUND}}| %a%f"

  zstyle ':vcs_info:*' stagedstr " $(p9k::print_icon 'VCS_STAGED_ICON')"
  zstyle ':vcs_info:*' unstagedstr " $(p9k::print_icon 'VCS_UNSTAGED_ICON')"

  p9k::defined P9K_VCS_GIT_HOOKS || P9K_VCS_GIT_HOOKS=(vcs-detect-changes git-untracked git-aheadbehind git-stash git-remotebranch git-tagname)
  zstyle ':vcs_info:git*+set-message:*' hooks $P9K_VCS_GIT_HOOKS
  p9k::defined P9K_VCS_HG_HOOKS || P9K_VCS_HG_HOOKS=(vcs-detect-changes)
  zstyle ':vcs_info:hg*+set-message:*' hooks $P9K_VCS_HG_HOOKS
  p9k::defined P9K_VCS_SVN_HOOKS || P9K_VCS_SVN_HOOKS=(vcs-detect-changes svn-detect-changes)
  zstyle ':vcs_info:svn*+set-message:*' hooks $P9K_VCS_SVN_HOOKS

  # For Hg, only show the branch name
  zstyle ':vcs_info:hg*:*' branchformat "$(p9k::print_icon 'VCS_BRANCH_ICON')%b"
  # The `get-revision` function must be turned on for dirty-check to work for Hg
  zstyle ':vcs_info:hg*:*' get-revision true
  zstyle ':vcs_info:hg*:*' get-bookmarks true
  zstyle ':vcs_info:hg*+gen-hg-bookmark-string:*' hooks hg-bookmarks

  # For svn, only
  # TODO fix the %b (branch) format for svn. Using %b breaks
  # color-encoding of the foreground for the rest of the powerline.
  zstyle ':vcs_info:svn*:*' formats "$VCS_CHANGESET_PREFIX%c%u"
  zstyle ':vcs_info:svn*:*' actionformats "$VCS_CHANGESET_PREFIX%c%u %F{${P9K_VCS_ACTIONFORMAT_FOREGROUND}}| %a%f"

  if [[ "$P9K_SHOW_CHANGESET" == true ]]; then
    zstyle ':vcs_info:*' get-revision true
  fi
}

powerlevel9k_vcs_init

################################################################
# Segment to show VCS information
prompt_vcs() {
  VCS_WORKDIR_DIRTY=false
  VCS_WORKDIR_HALF_DIRTY=false
  local current_state=""

  # Actually invoke vcs_info manually to gather all information.
  vcs_info
  local vcs_prompt="${vcs_info_msg_0_}"

  if [[ -n "$vcs_prompt" ]]; then
    if [[ "$VCS_WORKDIR_DIRTY" == true ]]; then
      # $vcs_visual_identifier gets set in +vi-vcs-detect-changes in functions/vcs.zsh,
      # as we have there access to vcs_info internal hooks.
      current_state='modified'
    else
      if [[ "$VCS_WORKDIR_HALF_DIRTY" == true ]]; then
        current_state='untracked'
      else
        current_state='clean'
      fi
    fi
    "__p9k_$1_prompt_segment" "${0}_${(U)current_state}" "$2" "${vcs_states[$current_state]}" "$DEFAULT_COLOR" "$vcs_prompt" "$vcs_visual_identifier"
  fi
}
