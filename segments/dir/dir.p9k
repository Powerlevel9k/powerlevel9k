# vim:ft=zsh ts=2 sw=2 sts=2 et fenc=utf-8
################################################################
# @title powerlevel9k Segment - Dir2
# @source [powerlevel9k](https://github.com/bhilburn/powerlevel9k)
##

() {
  # Set the right locale to protect special characters
  local LC_ALL="" LC_CTYPE="en_US.UTF-8"
  ################################################################
  # Register segment
  # Parameters:
  #   segment_name  context  background  foreground  Generic  Flat/Awesome-Patched  Awesome-FontConfig  Awesome-Mapped-FontConfig  NerdFont
  #                                                                                                                                     
  p9k::register_segment "DIR" 'DEFAULT'         "blue" "$DEFAULT_COLOR"   ''         $'\uE818'  $'\uF115'  '\u'${CODEPOINT_OF_AWESOME_FOLDER_O}     $'\uF115'
  #                                                                                                                                     
  p9k::register_segment "DIR" 'HOME'            "blue" "$DEFAULT_COLOR"   ''         $'\uE12C'  $'\uF015'  '\u'${CODEPOINT_OF_AWESOME_HOME}         $'\uF015'
  #                                                                                                                                     
  p9k::register_segment "DIR" 'HOME_SUBFOLDER'  "blue" "$DEFAULT_COLOR"   ''         $'\uE18D'  $'\uF07C'  '\u'${CODEPOINT_OF_AWESOME_FOLDER_OPEN}  $'\uF07C'
  #                                                                                                                                     
  p9k::register_segment "DIR" 'NOT_WRITABLE'    "blue" "$DEFAULT_COLOR"   $'\uE0A2'  $'\uE138'  $'\uF023'  '\u'${CODEPOINT_OF_AWESOME_LOCK}         $'\uF023'
  #                                                                                                                                   
  p9k::register_segment "DIR" 'ETC'             "blue" "$DEFAULT_COLOR"   $'\uE818'  $'\uF013'  $'\uF013'  '\u'${CODEPOINT_OF_AWESOME_COG}          $'\uF013'

  p9k::set_default P9K_DIR_PATH_SEPARATOR "/"
  p9k::set_default P9K_DIR_HOME_FOLDER_ABBREVIATION "~"
  p9k::set_default P9K_DIR_PATH_HIGHLIGHT_BOLD false
  p9k::set_default P9K_DIR_PATH_ABSOLUTE false
  p9k::set_default P9K_DIR_SHORTEN_DELIMITER "\u2026"
  p9k::set_default P9K_DIR_SHORTEN_FOLDER_MARKER ".shorten_folder_marker"
  # Parse the 'name' from the package.json; if there are any problems, just
  # print the file path
  p9k::defined P9K_DIR_PACKAGE_FILES || P9K_DIR_PACKAGE_FILES=(package.json composer.json)
}

################################################################
# Truncation
# These functions are for truncating strings using
# certain rules for the powerlevel9k-ZSH-theme
# https://github.com/bhilburn/powerlevel9k
#
# Be careful if you rename the functions in this file, as
# the truncation strategy name is used as key to access
# this functions. The name is lowercased, but the first
# character is uppercased and prefixed with "_p9k_truncate".
# Example: If you set "FolderMarker" as your strategy,
# "_p9k_truncateFoldermarker" will be called.
################################################################

# Parameters:
#   * $1 - subject
#   * $2 - substitute
function _p9k_truncateHome() {
  local subject="${1}"
  local substitute="${2}"

  # We just cut off the piece that gets truncated,
  # because we want to hand over the rest to the next
  # truncation strategy. So our truncatedPath is just
  # our substitute..
  local truncatedPath="${substitute}"
  local remainder="$(echo "${subject}" | sed -e "s,^$HOME,,")"
  [[ -n "${remainder}" ]] || remainder="false"
  # Check if $subject does not start with $HOME. If
  # so, we are outside of $HOME and need to reset
  # the truncatedPath and set $remainder to $subject.
  if [[ "${subject}" != "${HOME}"* ]]; then
    truncatedPath=""
    remainder="${subject}"
  fi

  # This is an encoded array! Delimiter is ";".
  echo "truncated;${truncatedPath};remainder;${remainder}"
}

# TODO: Make it work chained!
#
# This is a terminal truncation. After this one is
# applied, no other truncation strategy can be applied.
# Parameters:
#   * $1 - subject
#   * $2 - length
#   * $3 - substitute
function _p9k_truncateDirectories() {
  local subject="${1}"
  local length="${2}"
  local substitute="${3}"

  local delimiterPosition="$(strindex "${subject}" "/" "${length}" "right")"
  local truncatedPath="${substitute}${subject[$delimiterPosition,-1]}"

  # This is an encoded array! Delimiter is ";".
  echo "truncated;${truncatedPath};remainder;false"
}

# This is a terminal truncation. After this one is
# applied, no other truncation strategy can be applied.
# Parameters:
#   * $1 - subject
#   * $2 - length
#   * $3 - substitute
function _p9k_truncateMiddle() {
  local subject="${1}"
  local length=${2}
  local substitute="${3}"

  local truncatedPath=$(__p9k_truncate_path "${subject}" ${length} "${substitute}" "middle")
  # This is an encoded array! Delimiter is ";".
  echo "truncated;${truncatedPath};remainder;false"
}

# Given a directory path, truncate it according to the
# settings for `truncate_from_right`
#
# This is a terminal truncation. After this one is
# applied, no other truncation strategy can be applied.
# Parameters:
#   * $1 - subject
#   * $2 - length
#   * $3 - substitute
function _p9k_truncateRight() {
  local subject="${1}"
  local length=${2}
  local substitute="${3}"

  local truncatedPath=$(__p9k_truncate_path "${subject}" ${length} "${substitute}" "right")
  # This is an encoded array! Delimiter is ";".
  echo "truncated;${truncatedPath};remainder;false"
}

# Given a directory path, truncate it according to the
# settings for `truncate_from_left`
#
# This is a terminal truncation. After this one is
# applied, no other truncation strategy can be applied.
# Parameters:
#   * $1 - subject
#   * $2 - length
#   * $3 - substitute
function _p9k_truncateLeft() {
  local subject="${1}"
  local length=${2}
  local substitute="${3}"

  local truncatedPath=$(__p9k_truncate_path "${subject}" ${length} "${substitute}" "left")
  # This is an encoded array! Delimiter is ";".
  echo "truncated;${truncatedPath};remainder;false"
}

# Parameters:
#   * $1 - subject
function _p9k_truncatePackage() {
  local subject="${1}"

  p9k::defined POWERLEVEL9K_DIR_PACKAGE_FILES || POWERLEVEL9K_DIR_PACKAGE_FILES=("package.json" "composer.json")
  for stopfile in ${POWERLEVEL9K_DIR_PACKAGE_FILES}; do
    for marked_folder in $(__p9k_upsearch "${stopfile}"); do
      # Strip the path to the stopfile from the actual (deep),
      # path, so that we can prepend it with the package name.
      local pathSuffix="${subject:${#${(S%%)marked_folder//$~zero/}}}"

      local pkgFile="${marked_folder}/${stopfile}"
      local packageName=$(jq -r '.name' ${pkgFile} 2> /dev/null \
            || node -e 'console.log(require(process.argv[1]).name);' ${pkgFile} 2>/dev/null \
            || cat "${pkgFile}" 2> /dev/null | grep -m 1 "\"name\"" | awk -F ':' '{print $2}' | awk -F '"' '{print $2}' 2>/dev/null \
      )

      if [[ -n "${packageName}" ]]; then
        # set pathSuffix to false if empty
        if [[ -z "${pathSuffix}" ]]; then
          pathSuffix="false"
        fi
        # This is an encoded array! Delimiter is ";".
        echo "truncated;${packageName};remainder;${pathSuffix}"

        # Exit early. We got our information.
        return 0
      fi
    done
  done

  # set subject to false if empty
  if [[ -z "${subject}" ]]; then
      subject="false"
  fi

  # Nothing truncated, just return
  # the whole string as remainder.
  # This is an encoded array! Delimiter is ";".
  echo "truncated;false;remainder;${subject}"
}

# Truncate via folder marker
function _p9k_truncateFoldermarker() {
  local subject="${1}"
  local substitute="${2}"
  local stopfile="${3}"

  local marked_folder="$(upsearchToParentFolder "${stopfile}")"
  if [[ -n "${marked_folder}" ]]; then
    # This is an encoded array! Delimiter is ";".
    echo "truncated;${substitute};remainder;${subject#${marked_folder}}"

    return 0
  fi

  # Nothing truncated, just return
  # the whole string as remainder.
  # This is an encoded array! Delimiter is ";".
  echo "truncated;false;remainder;${subject}"
}

# Truncate if the terminal width exceeds a
# defined value.
# Parameters:
#   * $1 - subject
#   * $2 - substitute
#   * $3 - percentage
function _p9k_truncateTerminalwidth() {
  local subject="${1}"
  local substitute="${2}"
  typeset -F 2 percentage
  percentage="${3}"+0.00001

  local maxShownColumns=$(( COLUMNS * (percentage / 100) ))
  if [[ "${COLUMNS}" -gt "${maxShownColumns}" ]]; then
    # truncate to $maxShownColumns max
    local charsToTruncate=$(( int(rint(COLUMNS - maxShownColumns)) ))
    local remainder="${subject[-${charsToTruncate},-1]}"

    # This is an encoded array! Delimiter is ";".
    echo "truncated;${substitute};remainder;${remainder}"

    return 0
  fi

  # Nothing truncated, just return
  # the whole string as remainder.
  # This is an encoded array! Delimiter is ";".
  echo "truncated;false;remainder;${subject}"
}

################################################################
# @description
#   Display information about the current working directory.
##
# @args
#   $1 string Alignment - left | right
#   $2 integer Segment index
#   $3 boolean Whether the segment should be joined
##
prompt_dir() {
  [[ $P9K_GENERATOR == "zsh-async" && -n $4 ]] && cd $4

  p9k::defined P9K_DIR_SHORTEN_STRATEGY || P9K_DIR_SHORTEN_STRATEGY=("home" "middle")

  if [[ -n "${P9K_DIR_SHORTEN_DELIMITER}" ]]; then
    P9K_DIR_SHORTEN_ABBREVIATION="${P9K_DIR_SHORTEN_DELIMITER}"
  fi
  # For backwards compatiblity, translate old variable value to new value
  if [[ ! "${(t)P9K_DIR_SHORTEN_STRATEGY}" =~ "array" ]]; then
    [[ "${P9K_DIR_SHORTEN_STRATEGY}" == "truncate_with_package_name" ]] && P9K_DIR_SHORTEN_STRATEGY=("package" "home" "right")
    [[ "${P9K_DIR_SHORTEN_STRATEGY}" == "truncate_from_right" ]] && P9K_DIR_SHORTEN_STRATEGY=("home" "right")
    [[ "${P9K_DIR_SHORTEN_STRATEGY}" == "truncate_from_left" ]] && P9K_DIR_SHORTEN_STRATEGY=("home" "left")
    [[ "${P9K_DIR_SHORTEN_STRATEGY}" == "truncate_middle" ]] && P9K_DIR_SHORTEN_STRATEGY=("home" "middle")
    [[ "${P9K_DIR_SHORTEN_STRATEGY}" == "truncate_with_folder_marker" ]] && P9K_DIR_SHORTEN_STRATEGY=("foldermarker")
    # If it is still a string, just assume that the user has default strategy
    [[ ! "${(t)P9K_DIR_SHORTEN_STRATEGY}" =~ "array" ]] && P9K_DIR_SHORTEN_STRATEGY=("home" "directories")
  fi

  local current_path="${PWD}"

  # determine state
  local current_state="DEFAULT"
  # added '/private/etc' for macOS compatibility
  if [[ ${current_path} == '/etc'* || ${current_path} == '/private/etc'* ]]; then
    current_state='ETC'
  elif [[ "${P9K_DIR_SHOW_WRITABLE}" == true && ! -w "$PWD" ]]; then
    current_state="NOT_WRITABLE"
  elif [[ ${current_path} == "${HOME}" ]]; then
    current_state="HOME"
  elif [[ ${current_path} == "${HOME}"* ]]; then
    current_state="HOME_SUBFOLDER"
  fi

  # truncatedPath holds the truncated path. The truncation
  # functions return an associative array that contain a
  # key for the truncated path and a remainder that can be
  # handled by other truncation strategies. All truncation
  # strategies should apply their truncation from the left.
  local truncatedPath
  for strategyName in "${=P9K_DIR_SHORTEN_STRATEGY}"; do
    # Capitalize the name of the strategy, so that we can
    # call the right function.
    local strategy="_p9k_truncate${(C)strategyName}"
    local normalizedStrategyName="${(L)strategyName}"

    typeset -ah strategyOptions
    case "${normalizedStrategyName}" in
      "home")
        strategyOptions=("${P9K_DIR_HOME_FOLDER_ABBREVIATION}")
      ;;
      "package")
        # No options for package truncation.
        strategyOptions=()
      ;;
      "foldermarker")
        strategyOptions=("${P9K_DIR_SHORTEN_ABBREVIATION}" "${P9K_DIR_SHORTEN_FOLDER_MARKER}")
      ;;
      "terminalwidth")
        # P9K_SHORTEN_DIR_LENGTH means here the percentage of $COLUMNS that the string gets truncated to
        strategyOptions=("${P9K_DIR_SHORTEN_ABBREVIATION}" "${P9K_DIR_SHORTEN_LENGTH}")
      ;;
      *)
        strategyOptions=("${P9K_DIR_SHORTEN_LENGTH}" "${P9K_DIR_SHORTEN_ABBREVIATION}")
      ;;
    esac

    if [[ -n "${current_path}" ]]; then
      typeset -Ah truncationResult
      # Actually invoke the truncation
      # Split by semicolon (see https://unix.stackexchange.com/a/28873)
      truncationResult=("${(@s.;.)$(${strategy} "${current_path}" ${(@)strategyOptions})}")

      [[ "${truncationResult[truncated]}" != 'false' ]] && truncatedPath="${truncatedPath}${truncationResult[truncated]}"
      [[ "${truncationResult[remainder]}" == 'false' ]] && current_path="" || current_path="${truncationResult[remainder]}"
    fi
  done

  # Append the remainder
  truncatedPath="${truncatedPath}${current_path}"

  if [[ "${P9K_DIR_OMIT_FIRST_CHARACTER}" == "true" ]]; then
    truncatedPath="${truncatedPath[2,-1]}"
  fi

  # save state of path for highlighting and bold options
  local path_opt=$truncatedPath

  # declare variables used for bold and state colors
  local bld_on="" bld_off="" dir_state_foreground dir_state_user_foreground
  # test if user wants the last directory printed in bold
  if [[ "${(L)P9K_DIR_PATH_HIGHLIGHT_BOLD}" == "true" ]]; then
    bld_on="%B"
    bld_off="%b"
  fi
  # determine is the user has set a last directory color
  local dir_state_user_foreground=P9K_DIR_${current_state}_FOREGROUND
  local dir_state_foreground=$(p9k::foreground_color ${(P)dir_state_user_foreground})
  # if the user foreground is an empty string, p9k::foreground_color will return "%f" (reset foreground color)
  [[ ${dir_state_foreground} == "%f" ]] && dir_state_foreground=${__P9K_DATA[DIR_${current_state}_FG]}

  local dir_name base_name
  # use ZSH substitution to get the dirname and basename instead of calling external functions
  dir_name=${path_opt%/*}
  base_name=${path_opt##*/}

  # if the user wants the last directory colored...
  if [[ -n ${P9K_DIR_PATH_HIGHLIGHT_FOREGROUND} ]]; then
    local dir_path_highlight_foreground="$(p9k::foreground_color ${P9K_DIR_PATH_HIGHLIGHT_FOREGROUND})"
    # it the path is "/" or "~"
    if [[ ${path_opt} == "/" || ${path_opt} == "~" ]]; then
      truncatedPath="${bld_on}${dir_path_highlight_foreground}${truncatedPath}${bld_off}"
    else # has a subfolder
      # test if dirname != basename - they are equal if we use truncate_to_last or truncate_absolute
      if [[ ${dir_name} != ${base_name} ]]; then
        truncatedPath="${dir_name}/${bld_on}${dir_path_highlight_foreground}${base_name}${bld_off}"
      else
        truncatedPath="${bld_on}${dir_path_highlight_foreground}${base_name}${bld_off}"
      fi
    fi
  else # no coloring
    # it the path is "/" or "~"
    if [[ ${path_opt} == "/" || ${path_opt} == "~" ]]; then
      truncatedPath="${bld_on}${truncatedPath}${bld_off}"
    else # has a subfolder
      # test if dirname != basename - they are equal if we use truncate_to_last or truncate_absolute
      if [[ ${dir_name} != ${base_name} ]]; then
        truncatedPath="${dir_name}/${bld_on}${base_name}${bld_off}"
      else
        truncatedPath="${bld_on}${base_name}${bld_off}"
      fi
    fi
  fi

  # check if we need to omit the first character and only do it if we are not in "~" or "/"
  if [[ "${P9K_DIR_OMIT_FIRST_CHARACTER}" == "true" && ${path_opt} != "/" && ${path_opt} != "~" ]]; then
    truncatedPath="${truncatedPath[2,-1]}"
  fi

  # check if the user wants the separator colored.
  if [[ -n ${P9K_DIR_PATH_SEPARATOR_FOREGROUND} && ${path_opt} != "/" ]]; then
    local dir_path_separator_foreground=$(p9k::foreground_color ${P9K_DIR_PATH_SEPARATOR_FOREGROUND})
    # because this contains color changing codes, it is easier to set a variable for what should be replaced
    local repl="${dir_path_separator_foreground}/${dir_state_foreground}"
    # escape the / with a \
    truncatedPath=${truncatedPath//\//${repl}}
  fi

  if [[ "${P9K_DIR_PATH_SEPARATOR}" != "/" && ${path_opt} != "/" ]]; then
    truncatedPath=${truncatedPath//\//${P9K_DIR_PATH_SEPARATOR}}
  fi

  if [[ "${P9K_DIR_HOME_FOLDER_ABBREVIATION}" != "~" && ! "${(L)P9K_DIR_OMIT_FIRST_CHARACTER}" == "true" ]]; then
    # use :s to only replace the first occurance
    truncatedPath=${truncatedPath:s/~/${P9K_DIR_HOME_FOLDER_ABBREVIATION}}
  fi

  p9k::prepare_segment "$0" "${(U)current_state}" $1 "$2" $3 "${truncatedPath}"
}